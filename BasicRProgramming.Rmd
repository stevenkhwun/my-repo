---
title: Master the basics of R Programming
output:
  pdf_document: default
  word_document: default
  html_document:
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Introduction

R is a programming language created and developed in 1991 by two statisticians at the University of Auckland, in New Zealand. It officially became free and open-source only in 1995. For its origins, it provides statistical and graphical techniques, linear and non-linear models, techniques for time series, and many other functionalities. Even if Python is the most common in the Data Science field, R is still widely used for specialized purposes, like in financial companies, research, and healthcare.

# Assignment

When we program in R, the entities we work with are called objects [1]. They can be numbers, strings, vectors, matrices, arrays, functions. So, any generic data structure is an object. The assignment operator is `<-`, which combines the characters `<` and `-`. We can visualize the output of the object by calling it:


```{r}
# Assignment
x <- 23
```

A more complex example can be:
```{r}
# A more complex example
x <- 1/1+1*1
y <- x^4
z <- sqrt(y)
x
y
z
```


As you can notice, the mathematical operators are the ones you use for the calculator on the computer, so you don’t need the effort to remember them. There are also mathematical functions available, like `sqrt`, `abs`, `sin`, `cos`, `tan`, `exp`, and `log`.

# Vectors in R Programming

In R, the vectors constitute the simplest data structure. The elements within the vector are all of the same types. To create a vector, we only need the function `c()`:

```{r}
# Create vector
v1 <- c(2,4,6,8)
v1
```

This function simply concatenates different entities into a vector. There are other ways to create a vector, depending on the purpose. For example, we can be interested in creating a list of consecutive numbers and we don’t want to specify them manually. In this case, the syntax is `a:b` , where a and b correspond to the lower and upper extremes of this succession. The same result can be obtained using the function `seq()`


```{r}
# Creating a list of consecutive numbers
1:7
```

The function `seq()` can also be applied to create more complex sequences. For example, we can add the argument by the step size and the length of the sequence:


```{r}
# Create list by step size
v4 <- seq(0,1,by=0.1)
v4
# Create list by the length of the sequence
v5 <- seq(0,2,len=11)
v5
```

To repeat the same number more times into a vector, the function rep() can be used:

```{r}
# Repeat the same number more times into a vector
v6 <- rep(2,3)
v6
v7 <- c(1,rep(2,3),3)
v7
```

There are not only numerical vectors. There are also logical vectors and character vectors:

```{r}
# Logical vector
x <- 1:10
y <- 1:5
l <- x==y
l
# Character vector
c <- c('a','b','c')
c
```

# factors in R Programming

factors are specialized vectors used to group elements into categories. There are two types of factors: ordered and unordered. For example, we have the countries of five friends. We can create a factor using the function `factor()`


```{r}
# Create a factor
states <- c('italy','france','germany','germany','germany')
statesf <- factor(states)
statesf
```

To check the levels of the factor, the function `levels()` can be applied.

```{r}
# Check the levels of the factor
levels(statesf)
```

# Matrices in R Programming

As you probably know, the matrix is a 2-dimensional array of numbers. It can be built using the function `matrix()`

```{r}
# Creating a matrix
m1 <- matrix(1:6,nrow=3)
m1
m2 <- matrix(1:6,ncol=3)
m2
```

It can also be interesting combine different vectors into a matrix row-wise or column-wise. This is possible with `rbind()` and `cbind()`:

```{r}
# Combining vectors into matrix using rbind()
countries <- c('italy','france','germany')
age <- 25:27
rbind(countries,age)
# Or using cbind()
cbind(countries,age)
```

# Arrays in R Programming

Arrays are objects that can have one, two, or more dimensions. When the array is one-dimensional, it coincides with the vector. In the case it’s 2D, it’s like to use the matrix function. In other words, arrays are useful to build a data structure with more than 2 dimensions.

```{r}
# Creating an array
a <- array(1:16,dim=c(6,3,2))
a
```

# list

The list is a ordered collection of objects. For example, it can a collection of vectors, matrices. Differently from vectors, the lists can contain values of different type. They can be build using the function `list()`:

```{r}
# Creating a list
x <- 1:3
y <- c('a','b','c')
l <- list(x,y)
l
```

# Data frames in R Programming

A data frame is very similar to a matrix. It’s composed of rows and columns, where the columns are considered vectors. The most relevant difference is that it’s easier to filter and select elements. We can build manually the data frame using the function `data.frame()`:

```{r}
# Data frame
countries <- c('italy','france','germany')
age <- 25:27
df <- data.frame(countries,age)
df
```

An alternative is to read the content of a file and assign it to a data frame with the function `read.table()`:

```{r, eval=FALSE}
# read.table() function
df <- read.table('titanic.dat')
```

Like in Pandas, there are other functions to read files with different formats. For example, let’s read a csv file:

```{r}
# read.csv() function
df <- read.csv('Data/titanic.csv')
head(df)
```

Like in Python, R provides pre-loaded data using the function `data()`:

```{r}
# Load pre-loaded data
data("mtcars")
head(mtcars)
```

The function `head()` allows visualizing the first 6 rows of the mtcars dataset, which provides the data regarding fuel consumption and ten characteristics of 32 automobiles.

To check all the information about the dataset, you write this line of code:

```{r, eval=FALSE}
# This code not evaluated
help(mtcars)
```

In this way, a window with all the useful information will open. To have an overview of the dataset’s structure, the function `str()` can allow having additional insights into the data:

```{r}
# Structure of the data
str(mtcars)
```

From the output, it’s clear that there are 32 observations and 11 variables/columns. From the second line, there is a row for each variable that shows the type and the content. We show separately the same information using:

*   the function `dim()` to look at the dimensions of the data frame
*   the function `names()` to see the names of the variables

```{r}
# Dimensions of the data frame
dim(mtcars)
# Names of the variables
names(mtcars)
```

The summary statistics of the variables can be obtained through the function `summary()`.

```{r}
# Summary of the data
summary(mtcars)
```

We can access specific columns using the expression `namedataset$namevariable`. If we want to avoid specifying every time the name of the dataset, we need the function `attach()`.

```{r}
# Using $ sign expression
mtcars$mpg
# Using attach() function
attach(mtcars)
mpg
```

In this way, we attach the data frame to the search path, allowing to refer to the columns with only their names. Once we attached the data frame and we aren’t interested anymore to use it, we can do the inverse operation using the function `detach()`.

We can also try to select the first row in the data frame using this syntax:

```{r}
# Select the first row
mtcars[1,]
```

Note that the index starts from 1, not from 0! If we want to extract the first columns, it can be done in this way:

```{r}
# Select the first column
mtcars[,1]
```

We can also try to filter the rows using a logical expression:

```{r}
# Filter with logical expression
mtcars[mpg>20,]
```

we can also specify the column while we filter:


```{r}
# Specify the column while filter
mtcars[mpg>20, 'mpg']
```
